import parser { BinaryOperator, FunctionLinkage }
import typechecker {
    BuiltinType, CheckedBlock, CheckedCall, CheckedExpression,
    CheckedFunction, CheckedProgram, CheckedStatement, CheckedStruct,
    Module, ModuleId, Scope, ScopeId, StructId, EnumId, Type, TypeId, expression_type,
    CheckedEnum, unknown_type_id, CheckedMatchCase, FunctionId, CheckedMatchBody, void_type_id,
    CheckedVariable, NumberConstant, CheckedEnumVariant}
import utility { panic, todo, join, prepend_to_each, Span }
import compiler { Compiler }

enum Mutability {
    DoesNotApply
    Immutable
    Mutable
}

enum VarType {
    Variable
    Field
}

enum VarVisibility {
    DoesNotApply
    Public
    Private
    Restricted
}

enum Usage {
    Variable(
        span: Span
        name: String
        type_id: TypeId
        mutability: Mutability
        var_type: VarType
        visibility: VarVisibility
        struct_type_id: TypeId?)
    Call(FunctionId)
    Typename(TypeId)
    NameSet([String])
    EnumVariant(
        span: Span
        name: String
        type_id: TypeId
        variants: [(String?, TypeId)]
        number_constant: NumberConstant?
    )
}

function find_definition_in_program(program: CheckedProgram, span: Span) throws -> Span {
    let result = find_span_in_program(program, span)
    if result.has_value() {
        return match result! {
            Variable(span) => span
            Call(function_id) => program.get_function(function_id).name_span
            Typename(type_id) => find_type_definition_for_type_id(program, type_id, span)
            NameSet() => span
            EnumVariant(span) => span
        }
    } else {
        return span
    }
}

function find_type_definition_for_type_id(program: CheckedProgram, type_id: TypeId, span: Span) throws -> Span {
    let array_struct_id = program.find_struct_in_prelude("Array")
    let dictionary_struct_id = program.find_struct_in_prelude("Dictionary")
    let optional_struct_id = program.find_struct_in_prelude("Optional")
    let range_struct_id = program.find_struct_in_prelude("Range")
    let set_struct_id = program.find_struct_in_prelude("Set")
    let tuple_struct_id = program.find_struct_in_prelude("Tuple")
    let weak_ptr_struct_id = program.find_struct_in_prelude("WeakPtr")

    return match program.get_type(type_id) {
        F32 => span
        F64 => span
        I8 => span
        I16 => span
        I32 => span
        I64 => span
        U8 => span
        U16 => span
        U32 => span
        U64 => span
        Usize => span
        CChar => span
        CInt => span
        Bool => span
        Void => span
        Unknown => span
        JaktString => span
        GenericInstance(id: struct_id, args) => {
            mut output = span
            if struct_id.equals(array_struct_id) or struct_id.equals(optional_struct_id) or struct_id.equals(range_struct_id) or struct_id.equals(set_struct_id) or struct_id.equals(tuple_struct_id) or struct_id.equals(weak_ptr_struct_id) {
                output = find_type_definition_for_type_id(program, type_id: args[0], span)
            } else if struct_id.equals(dictionary_struct_id) {
                output = find_type_definition_for_type_id(program, type_id: args[1], span)
            } else {
                output = program.get_struct(struct_id).name_span
            }
            yield output
        }
        Struct(struct_id) => program.get_struct(struct_id).name_span
        GenericEnumInstance(id) => program.get_enum(id).name_span
        Enum(id) => program.get_enum(id).name_span
        RawPtr(type_id) => find_type_definition_for_type_id(program, type_id, span)
        TypeVariable() => span
        GenericResolvedType(id) => program.get_struct(id).name_span
    }
}

function find_span_in_program(program: CheckedProgram, span: Span) throws -> Usage? {
    mut iterator = program.modules.iterator()
    iterator.next()
    for module in iterator {
        let scope = program.get_scope(ScopeId(module_id: module.id, id: 0))

        return find_span_in_scope(program, scope, span)
    }

    return None
}

function find_type_definition_in_program(program: CheckedProgram, span: Span) throws -> Span {
    let result = find_span_in_program(program, span)

    if result.has_value() {
        return match result! {
            Variable(span, type_id) => {
               yield find_type_definition_for_type_id(program, type_id, span)
            }
            Call(function_id) => {
                yield program.get_function(function_id).name_span
            }
            Typename(type_id) => {
                yield find_type_definition_for_type_id(program, type_id, span)
            }
            NameSet() => span
            EnumVariant(span) => span
        }
    } else {
        return span
    }
}

function find_typename_in_program(program: CheckedProgram, span: Span) throws -> String? {
    let result = find_span_in_program(program, span)

    if result.has_value() {
        return match result! {
            Variable(name, type_id, mutability, var_type, visibility, struct_type_id) => {
                let result = get_var_signature(program, name, var_type_id: type_id, mutability, var_type, visibility, struct_type_id)
                yield Some(result)
            }
            else => {
                let none_value: String? = None
                yield none_value
            }
        }
    } else {
        return None
    }
}

function find_span_in_scope(program: CheckedProgram, scope: Scope, span: Span) throws -> Usage? {
    for scope_var in scope.vars.iterator() {
        let var = program.get_variable(scope_var.1)
        if var.definition_span.contains(span) {
            return Some(Usage::Typename(var.type_id))
        }
    }

    for function_id in scope.functions.iterator() {
        let checked_function = program.get_function(function_id.1)
        let usage = find_span_in_function(program, checked_function, span)
        if usage.has_value() {
            return usage!
        }
    }

    for struct_id in scope.structs.iterator() {
        let checked_struct = program.get_struct(struct_id.1)
        let usage = find_span_in_struct(program, checked_struct, span)
        if usage.has_value() {
            return usage!
        }
    }

    for enum_id in scope.enums.iterator() {
        let checked_enum = program.get_enum(enum_id.1)
        let usage = find_span_in_enum(program, checked_enum, span)
        if usage.has_value() {
            return usage!
        }
    }

    for child in scope.children.iterator() {
        let scope = program.get_scope(child)

        let usage = find_span_in_scope(program, scope, span)
        if usage.has_value() {
            return usage!
        }
    }

    return None
}

function find_span_in_enum(program: CheckedProgram, checked_enum: CheckedEnum, span: Span) throws -> Usage? {
    let scope = program.get_scope(checked_enum.scope_id)

    for variant in checked_enum.variants.iterator() {
        match variant {
            StructLike(name, fields, span: variant_span) => {
                for field in fields.iterator() {
                    let var = program.get_variable(field)

                    if var.definition_span.contains(span) {
                        return Some(Usage::Typename(var.type_id))
                    }
                }

                if variant_span.contains(span) {
                    return Some(Usage::EnumVariant(span, name, type_id: checked_enum.type_id, variants: [], number_constant: None))
                }
            }
            Typed(name, span: variant_span) => {
                if variant_span.contains(span) {
                    return Some(Usage::EnumVariant(span: variant_span, name, type_id: checked_enum.type_id, variants: enum_variant_fields(program, checked_enum_variant: variant), number_constant: None))
                }
            }
            Untyped(name, span: variant_span) => {
                let number_constant_none: NumberConstant? = None
                return Some(Usage::EnumVariant(span: variant_span, name, type_id: checked_enum.type_id, variants: [], number_constant: number_constant_none))
            }
            WithValue(name, expr, span: variant_span) => {

                if variant_span.contains(span) {
                    return Some(Usage::EnumVariant(span: variant_span, name, type_id: checked_enum.type_id, variants: enum_variant_fields(program, checked_enum_variant: variant), number_constant: expr.to_number_constant(program)))
                }
            }
        }
    }

    return None
}

function find_span_in_struct(program: CheckedProgram, checked_struct: CheckedStruct, span: Span) throws -> Usage? {
    let scope = program.get_scope(checked_struct.scope_id)

    for field in checked_struct.fields.iterator() {
        let variable = program.get_variable(field)

        if variable.definition_span.contains(span) {
            return Some(Usage::Typename(variable.type_id))
        }
    }

    let usage = find_span_in_scope(program, scope, span)

    return usage
}

function find_span_in_function(program: CheckedProgram, checked_function: CheckedFunction, span: Span) -> Usage? {
    if checked_function.return_type_span.has_value() {
        if checked_function.return_type_span!.contains(span) {
            return Some(Usage::Typename(type_id: checked_function.return_type_id))
        }
    }

    for param in checked_function.params.iterator() {
        if param.variable.definition_span.contains(span) {
            return Some(Usage::Typename(param.variable.type_id))
        }
    }

    //FIXME: return find_span_in_block(program, block: function.block, span)
    return None
}

function get_var_signature(program: CheckedProgram, name: String, var_type_id: TypeId, mutability: Mutability, var_type: VarType, visibility: VarVisibility, struct_type_id: TypeId?) throws -> String {
    return match var_type {
        Variable => {
            let mut_string = match mutability {
                Mutable => "mut"
                Immutable => "let"
                else => ""
            }
            let type_name = get_type_signature(program, type_id: var_type_id)
            yield format("{} {}: {}", mut_string, name, type_name)
        }
        Field => {
            mut record_string = ""
            if struct_type_id.has_value() {
                record_string = get_type_signature(program, type_id: struct_type_id!)
            }
            let visibility_string = match visibility {
                Public => "public "
                Private => "private "
                else => ""
            }

            let type_name = get_type_signature(program, type_id: var_type_id)
            if record_string != "" {
                return format("{}\\n\\t{}{}: {}", record_string, visibility_string, name, type_name)
            } else {
                return format("{}{}: {}", visibility_string, name, type_name)
            }
        }
    }
}

function get_type_signature(program: CheckedProgram, type_id: TypeId) throws -> String {
    let array_struct_id = program.find_struct_in_prelude("Array")
    let dictionary_struct_id = program.find_struct_in_prelude("Dictionary")
    let optional_struct_id = program.find_struct_in_prelude("Optional")
    let range_struct_id = program.find_struct_in_prelude("Range")
    let set_struct_id = program.find_struct_in_prelude("Set")
    let tuple_struct_id = program.find_struct_in_prelude("Tuple")
    let weak_ptr_struct_id = program.find_struct_in_prelude("WeakPtr")

    let type = program.get_type(type_id)

    return match type {
        Void => "void"
        Bool => "bool"
        U8 => "u8"
        U16 => "u16"
        U32 => "u32"
        U64 => "u64"
        I8 => "i8"
        I16 => "i16"
        I32 => "i32"
        I64 => "i64"
        F32 => "f32"
        F64 => "f64"
        Usize => "usize"
        JaktString => "String"
        CInt => "c_int"
        CChar => "c_char"
        TypeVariable(name) => name
        Unknown => ""
        RawPtr(type_id) => "raw " + get_type_signature(program, type_id)
        Enum(id) => {
            let enum_ = program.get_enum(id)
            yield match enum_.is_boxed {
                true => "boxed "
                else => ""
            } + "enum " + enum_.name
        }
        Struct(id) => {
            let struct_ = program.get_struct(id)
            yield match struct_.record_type {
                Class => "class "
                Struct => "struct "
                else => {
                    panic("unreachable: should've been struct")
                    yield ""
                }
            } + struct_.name
        }
        GenericResolvedType(id, args) => {
            let record = program.get_struct(id)
            mut output = record.name
            output += "<"
            if not args.is_empty() {
                output += get_type_signature(program, type_id: args[0])
                for i in 1..args.size() {
                    output += ", "
                    output += get_type_signature(program, type_id: args[i])
                }
            }
            yield output + ">"
        }
        GenericEnumInstance(id, args) => {
            let enum_ = program.get_enum(id)
            mut output = ""
            if enum_.is_boxed {
                output += "boxed "
            }
            output += "enum "
            output += enum_.name
            output += "<"
            if not args.is_empty() {
                output += get_type_signature(program, type_id: args[0])
                for i in 1..args.size() {
                    output += ", "
                    output += get_type_signature(program, type_id: args[i])
                }
            }
            yield output + ">"
        }
        GenericInstance(id, args) => {
            if id.equals(array_struct_id) {
                if args.is_empty() {
                    return "[]"
                }
                return format("[{}]", get_type_signature(program, type_id: args[0]))
            }
            if id.equals(dictionary_struct_id) {
                if args.size() < 2 {
                    return "[:]"
                }
                return format("[{}: {}]",
                    get_type_signature(program, type_id: args[0])
                    get_type_signature(program, type_id: args[1]))
            }
            if id.equals(optional_struct_id) {
                if args.is_empty() {
                    return ""
                }
                return format("{}?", get_type_signature(program, type_id: args[0]))
            }
            if id.equals(range_struct_id) {
                if args.is_empty() {
                    return ""
                }
                // Ranges probably only make sense for builtin types, but if not we use the format
                // struct MyRangeStruct..MyRangeStruct
                return format("{}..{}",
                    get_type_signature(program, type_id: args[0])
                    program.type_name(args[0]))
            }
            if id.equals(set_struct_id) {
                if args.is_empty() {
                    return ""
                }
                return format("{{{}}}", get_type_signature(program, type_id: args[0]))
            }
            if id.equals(tuple_struct_id) {
                mut output = "("
                if not args.is_empty() {
                    output += get_type_signature(program, type_id: args[0])
                    for i in 1..args.size() {
                        output += ", "
                        output += get_type_signature(program, type_id: args[i])
                    }
                }
                return output + ")"
            }
            if id.equals(weak_ptr_struct_id) {
                if args.is_empty() {
                    return ""
                }
                return format("weak {}?", get_type_signature(program, type_id: args[0]))
            }

            let record = program.get_struct(id)
            mut output = match record.record_type {
                Class => "class "
                Struct => "struct "
                ValueEnum | SumEnum => {
                    panic("unreachable: can't be an enum")
                    yield ""
                }
                Garbage => ""
            }
            output += record.name
            output += "<"
            if not args.is_empty() {
                output += get_type_signature(program, type_id: args[0])
                for i in 1..args.size() {
                    output += ", "
                    output += get_type_signature(program, type_id: args[i])
                }
            }
            yield output + ">"
        }
    }
}

function enum_variant_fields(program: CheckedProgram, checked_enum_variant: CheckedEnumVariant) throws -> [(String?, TypeId)] {
    return match checked_enum_variant {
        StructLike(fields) => {
            mut output: [(String?, TypeId)] = []
            for field in fields.iterator() {
                let variable = program.get_variable(field)
                let var_name = Some(variable.name)
                let o = (var_name, variable.type_id)
                output.push(o)
            }
            yield output
        }
        Typed(type_id) => {
            let string_none: String? = None
            yield [(string_none, type_id)]
        }
        else => []
    }
}
